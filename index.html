<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MULtty - Terminal Serial Compartilhado</title>
    
    <!-- Carrega o arquivo LOCAL baixado anteriormente -->
    <script src="mqttws31.min.js" type="text/javascript"></script>

    <style>
        :root {
            --bg-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #00bcd4;
            --terminal-bg: #000000;
            --terminal-text: #00ff00;
            --chat-bg: #2d2d2d;
            --border-color: #444;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: #252526;
            border-bottom: 1px solid var(--border-color);
            height: 60px;
            flex-shrink: 0;
        }

        .login-area { display: flex; gap: 10px; align-items: center; }

        input[type="text"] {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: #3c3c3c;
            color: white;
            outline: none;
        }

        button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            background-color: var(--accent-color);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        button:hover:not(:disabled) { opacity: 0.8; }
        button:disabled { background-color: #555; cursor: not-allowed; }

        .app-title {
            font-size: 1.5rem;
            font-weight: bold;
            /* --- TÍTULO VERMELHO PARA VERIFICAÇÃO --- */
            color: #ff4444; 
            letter-spacing: 2px;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .left-column {
            width: 33.33%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            min-width: 300px;
        }

        .right-column {
            width: 66.67%;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .panel { display: flex; flex-direction: column; padding: 10px; position: relative; }

        .panel-header {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 5px;
            border-bottom: 1px solid #333;
            padding-bottom: 2px;
        }

        #chat-panel {
            flex: 1;
            background-color: var(--chat-bg);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.9rem;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .msg { word-wrap: break-word; }
        .msg .sender { font-weight: bold; color: var(--accent-color); }
        .msg.system { color: #ffd700; font-style: italic; font-size: 0.85rem; }
        .msg.error { color: #ff4444; }

        #chat-input-area {
            display: flex;
            padding: 10px;
            background: #252526;
            border-top: 1px solid var(--border-color);
        }
        #chat-input-area input { flex: 1; }

        #users-panel {
            height: 150px;
            background-color: #252526;
            overflow-y: auto;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .user-item {
            padding: 5px 10px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .user-item.me { color: var(--accent-color); font-weight: bold; }
        .user-item .serial-indicator {
            font-size: 0.7rem;
            background: #4caf50;
            color: #000;
            padding: 2px 5px;
            border-radius: 3px;
            display: none;
        }
        .user-item.has-serial .serial-indicator { display: inline-block; }

        #terminal-panel {
            flex: 1;
            background-color: var(--terminal-bg);
            color: var(--terminal-text);
            font-family: 'Courier New', Courier, monospace;
            padding: 10px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        #terminal-output {
            flex: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            font-size: 1rem;
            line-height: 1.2;
            height: 100%;
        }
        #terminal-input-hidden {
            position: absolute;
            opacity: 0;
            top: -1000px;
        }
        .terminal-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            padding: 5px 0;
            border-top: 1px solid #333;
            margin-top: 5px;
        }
        .control-group { display: flex; gap: 2px; }
        .control-input { width: 30px !important; padding: 0 !important; text-align: center; }
        .btn-special { font-size: 0.8rem; background-color: #444; padding: 4px; }

        #serial-data-panel {
            height: 120px;
            background-color: #1a1a1a;
            border-top: 1px solid var(--border-color);
            overflow-y: auto;
            padding: 10px;
            font-family: monospace;
            font-size: 0.8rem;
            color: #aaa;
            flex-shrink: 0;
        }
        .log-tx { color: #ff6b6b; }
        .log-rx { color: #4ecdc4; }

        @media (max-width: 768px) {
            .main-container { flex-direction: column; overflow-y: auto; }
            .left-column, .right-column { width: 100%; border-right: none; height: 50vh; }
            header { flex-direction: column; height: auto; gap: 10px; padding-bottom: 15px; }
            .login-area { width: 100%; }
            .login-area input { flex: 1; }
        }
    </style>
</head>
<body>

    <header>
        <div class="login-area" id="login-area">
            <input type="text" id="username" placeholder="Seu Nome" maxlength="15">
            <input type="text" id="roomname" placeholder="Sala (ex: sala1)" value="sala1">
            <button onclick="enterRoom()">Entrar</button>
        </div>
        <div class="app-title">MULtty</div>
        <div>
            <button id="btn-connect-serial" onclick="connectSerial()">Conectar Serial</button>
        </div>
    </header>

    <div class="main-container" id="main-interface" style="display:none;">
        
        <div class="left-column">
            <div class="panel" id="chat-panel">
                <div class="panel-header">Chat</div>
                <div id="chat-messages"></div>
                <div id="chat-input-area">
                    <input type="text" id="chat-msg-input" placeholder="Digite uma mensagem..." disabled>
                    <button id="btn-send-chat" onclick="sendChat()" disabled>Enviar</button>
                </div>
            </div>
            <div class="panel" id="users-panel">
                <div class="panel-header">Usuários na Sala</div>
                <div id="users-list"></div>
            </div>
        </div>

        <div class="right-column">
            <div class="panel" id="terminal-panel" onclick="focusTerminalInput()">
                <div class="panel-header">Terminal</div>
                <div id="terminal-output">Aguardando conexão serial...</div>
                
                <div class="terminal-controls">
                    <button class="btn-special" onclick="sendSpecialChar('\t')">TAB</button>
                    <button class="btn-special" onclick="sendSpecialChar('\x1b[A')">↑</button>
                    <button class="btn-special" onclick="sendSpecialChar('\x1b[B')">↓</button>
                    <button class="btn-special" onclick="sendSpecialChar('\x1b[C')">→</button>
                    <button class="btn-special" onclick="sendSpecialChar('\x1b[D')">←</button>
                    
                    <div class="control-group">
                        <button class="btn-special" onclick="sendModifiedKey('c')">Ctrl+</button>
                        <input type="text" id="ctrl-char" class="control-input" maxlength="1" placeholder="A">
                    </div>
                    <div class="control-group">
                        <button class="btn-special" onclick="sendModifiedKey('a')">Alt+</button>
                        <input type="text" id="alt-char" class="control-input" maxlength="1" placeholder="A">
                    </div>
                </div>
            </div>

            <input type="text" id="terminal-input-hidden" autocomplete="off">

            <div class="panel" id="serial-data-panel">
                <div class="panel-header">Serial Data</div>
                <div id="serial-log"></div>
            </div>
        </div>
    </div>

    <script>
        if (typeof Paho === 'undefined') {
            alert("Erro Crítico: Não foi possível encontrar o arquivo 'mqttws31.min.js'.");
        }

        const MQTT_HOST = "broker.emqx.io";
        const MQTT_PORT = 8084;
        const MQTT_PATH = "/mqtt";
        let mqttClient = null;
        let isConnectedToMQTT = false;

        let currentUser = "";
        let currentRoom = "";
        let myId = "user_" + Math.random().toString(16).substr(2, 8);
        
        let serialPort = null;
        let serialWriter = null;
        let serialReader = null;
        let isSerialConnected = false;
        let serialLockedBy = null;

        // --- VARIÁVEIS PARA BUFFERING (ANTI-FLOODING) ---
        let serialOutBuffer = ""; // Acumula dados para enviar
        let lastMqttFlush = 0;    // Timestamp do último envio
        const FLUSH_INTERVAL = 200; // Envia a cada 200ms
        const MAX_PACKET_SIZE = 4096; // Tamanho máximo seguro por pacote

        const elUsername = document.getElementById('username');
        const elRoomname = document.getElementById('roomname');
        const elMainInterface = document.getElementById('main-interface');
        const elBtnConnectSerial = document.getElementById('btn-connect-serial');
        const elChatMessages = document.getElementById('chat-messages');
        const elChatInput = document.getElementById('chat-msg-input');
        const elBtnSendChat = document.getElementById('btn-send-chat');
        const elTerminalOutput = document.getElementById('terminal-output');
        const elTerminalInputHidden = document.getElementById('terminal-input-hidden');
        const elUsersList = document.getElementById('users-list');
        const elSerialLog = document.getElementById('serial-log');

        let users = {};

        function enterRoom() {
            const name = elUsername.value.trim();
            const room = elRoomname.value.trim();

            if (!name || !room) {
                alert("Por favor, insira Nome e Sala.");
                return;
            }

            currentUser = name;
            currentRoom = room;

            document.getElementById('login-area').style.display = 'none';
            elMainInterface.style.display = 'flex';
            
            elChatInput.disabled = false;
            elBtnSendChat.disabled = false;

            addSystemMessage("Iniciando conexão segura (WSS) com broker.emqx.io...", 'system');
            initMQTT();
        }

        function initMQTT() {
            const clientId = "multry_" + myId + "_" + Date.now();
            mqttClient = new Paho.MQTT.Client(MQTT_HOST, MQTT_PORT, MQTT_PATH, clientId);

            mqttClient.onConnectionLost = onConnectionLost;
            mqttClient.onMessageArrived = onMessageArrived;

            const connectOptions = {
                onSuccess: onConnect,
                onFailure: onFailure,
                useSSL: true,
                keepAliveInterval: 30,
                timeout: 10,
                mqttVersion: 4
            };

            mqttClient.connect(connectOptions);
        }

        function onFailure(responseObject) {
            console.error("Connection failed: ", responseObject);
            addSystemMessage(`Falha na conexão: ${responseObject.errorMessage || "Erro desconhecido"}`, 'error');
            elBtnConnectSerial.disabled = false; 
        }

        function onConnect() {
            isConnectedToMQTT = true;
            addSystemMessage("Conectado ao chat com sucesso!", 'system');

            const topicBase = `multry/${currentRoom}`;
            
            mqttClient.subscribe(`${topicBase}/chat`);
            mqttClient.subscribe(`${topicBase}/presence`);
            mqttClient.subscribe(`${topicBase}/serial/data`);
            mqttClient.subscribe(`${topicBase}/serial/input`);
            mqttClient.subscribe(`${topicBase}/serial/lock`);

            publishMessage(`${topicBase}/presence`, JSON.stringify({
                type: 'join',
                id: myId,
                name: currentUser,
                hasSerial: false
            }));

            if (!serialLockedBy) {
                elBtnConnectSerial.disabled = false;
            }

            focusTerminalInput();
        }

        function onConnectionLost(responseObject) {
            isConnectedToMQTT = false;
            if (responseObject.errorCode !== 0) {
                addSystemMessage("Desconectado: " + (responseObject.errorMessage || "Erro genérico"), 'error');
            } else {
                addSystemMessage("Desconectado do servidor.", 'system');
            }
            
            setTimeout(() => {
                if (document.getElementById('main-interface').style.display !== 'none') {
                    addSystemMessage("Tentando reconectar...", 'system');
                    initMQTT();
                }
            }, 5000);
        }

        function publishMessage(topic, payload) {
            if (!isConnectedToMQTT) return;
            try {
                const message = new Paho.MQTT.Message(payload);
                message.destinationName = topic;
                message.qos = 1; 
                mqttClient.send(message);
            } catch (e) {
                console.error("Erro ao enviar msg", e);
            }
        }

        // --- NOVA LÓGICA DE ENVIO: BUFFER CONTROLADO ---
        // Isso evita o flooding e garante que pacotes não sejam descartados pelo broker.
        function flushSerialBuffer() {
            if (serialOutBuffer.length === 0) return;

            const now = Date.now();
            // Envia apenas se passou 200ms ou se o buffer está muito grande (para evitar lag excessivo)
            if (now - lastMqttFlush < FLUSH_INTERVAL && serialOutBuffer.length < MAX_PACKET_SIZE) {
                return;
            }

            const topicBase = `multry/${currentRoom}`;
            const topic = `${topicBase}/serial/data`;

            // Divide o buffer atual em pedaços de tamanho seguro (MAX_PACKET_SIZE)
            // Se o buffer tiver 12KB, envia 3 pacotes seguidos, mas depois para e espera 200ms
            while (serialOutBuffer.length > 0) {
                const chunk = serialOutBuffer.substring(0, MAX_PACKET_SIZE);
                serialOutBuffer = serialOutBuffer.substring(MAX_PACKET_SIZE);
                
                publishMessage(topic, chunk);
                logSerialData(chunk, 'tx');
            }

            lastMqttFlush = now;
        }

        function onMessageArrived(message) {
            const topic = message.destinationName;
            const payload = message.payloadString;
            const topicBase = `multry/${currentRoom}`;

            try {
                if (topic === `${topicBase}/chat`) {
                    const data = JSON.parse(payload);
                    addChatMessage(data.sender, data.text);
                }
                else if (topic === `${topicBase}/presence`) {
                    const data = JSON.parse(payload);
                    handlePresence(data);
                }
                else if (topic === `${topicBase}/serial/data`) {
                    if (isSerialConnected) {
                        // O usuário conectado vê localmente, o MQTT serve apenas de transporte
                        // Mas o log é útil para debug de tráfego de rede
                        logSerialData(payload, 'rx');
                    } else {
                        // Usuário remoto
                        appendToTerminal(payload);
                        logSerialData(payload, 'rx');
                    }
                }
                else if (topic === `${topicBase}/serial/input`) {
                    if (isSerialConnected && serialWriter) {
                        serialWriter.write(payload);
                        logSerialData(payload, 'tx');
                    }
                }
                else if (topic === `${topicBase}/serial/lock`) {
                    const data = JSON.parse(payload);
                    updateSerialLock(data);
                }
            } catch (e) {
                console.error("Erro parse JSON", e);
            }
        }

        function sendChat() {
            const text = elChatInput.value.trim();
            if (!text) return;

            const topicBase = `multry/${currentRoom}`;
            const payload = JSON.stringify({ sender: currentUser, text: text });
            publishMessage(`${topicBase}/chat`, payload);
            elChatInput.value = '';
        }

        elChatInput.addEventListener('keypress', function (e) {
            if (e.key === 'Enter') sendChat();
        });

        function addChatMessage(sender, text) {
            const div = document.createElement('div');
            div.className = 'msg';
            div.innerHTML = `<span class="sender">${sender}:</span> ${escapeHtml(text)}`;
            elChatMessages.appendChild(div);
            elChatMessages.scrollTop = elChatMessages.scrollHeight;
        }

        function addSystemMessage(text, type = 'system') {
            const div = document.createElement('div');
            div.className = `msg ${type}`;
            div.textContent = text;
            elChatMessages.appendChild(div);
            elChatMessages.scrollTop = elChatMessages.scrollHeight;
        }

        function handlePresence(data) {
            if (data.id === myId) return;

            if (data.type === 'join') {
                if (!users[data.id]) {
                    users[data.id] = { name: data.name, hasSerial: false };
                    addSystemMessage(`${data.name} entrou na sala.`);
                    const topicBase = `multry/${currentRoom}`;
                    publishMessage(`${topicBase}/presence`, JSON.stringify({
                        type: 'announce',
                        id: myId,
                        name: currentUser,
                        hasSerial: isSerialConnected
                    }));
                }
            } 
            else if (data.type === 'announce') {
                users[data.id] = { name: data.name, hasSerial: data.hasSerial };
            }
            else if (data.type === 'leave') {
                if (users[data.id]) {
                    addSystemMessage(`${users[data.id].name} saiu da sala.`);
                    delete users[data.id];
                }
            }
            else if (data.type === 'update_serial') {
                if (users[data.id]) {
                    users[data.id].hasSerial = data.hasSerial;
                }
            }
            renderUsers();
        }

        function renderUsers() {
            elUsersList.innerHTML = '';
            
            const meDiv = document.createElement('div');
            meDiv.className = 'user-item me';
            meDiv.innerHTML = `
                ${currentUser} (Eu)
                <span class="serial-indicator">Serial Conectada</span>
            `;
            if (isSerialConnected) meDiv.classList.add('has-serial');
            elUsersList.appendChild(meDiv);

            for (let id in users) {
                const u = users[id];
                const div = document.createElement('div');
                div.className = 'user-item';
                div.innerHTML = `
                    ${u.name}
                    <span class="serial-indicator">Serial Conectada</span>
                `;
                if (u.hasSerial) div.classList.add('has-serial');
                elUsersList.appendChild(div);
            }
        }

        async function connectSerial() {
            if (!("serial" in navigator)) {
                alert("Web Serial API não suportada. Use Chrome/Edge/Opera.");
                return;
            }

            try {
                serialPort = await navigator.serial.requestPort();
                await serialPort.open({ baudRate: 9600 });

                const textEncoder = new TextEncoderStream();
                textEncoder.readable.pipeTo(serialPort.writable).catch(err => console.error("Erro pipe Writable", err));
                serialWriter = textEncoder.writable.getWriter();

                const textDecoder = new TextDecoderStream();
                serialPort.readable.pipeTo(textDecoder.writable).catch(err => console.error("Erro pipe Readable", err));
                const reader = textDecoder.readable.getReader();
                serialReader = reader;

                isSerialConnected = true;
                
                // Limpa buffer ao conectar
                serialOutBuffer = "";
                lastMqttFlush = Date.now();

                elBtnConnectSerial.textContent = "Serial Conectada";
                elBtnConnectSerial.disabled = true;
                elTerminalOutput.textContent = ""; 
                addSystemMessage("Conexão Serial local estabelecida.", 'system');
                logSerialData("--- Serial Conectada ---", 'rx');

                const topicBase = `multry/${currentRoom}`;
                if (isConnectedToMQTT) {
                    publishMessage(`${topicBase}/serial/lock`, JSON.stringify({ action: 'lock', id: myId, name: currentUser }));
                    publishMessage(`${topicBase}/presence`, JSON.stringify({ type: 'update_serial', id: myId, hasSerial: true }));
                }

                readSerialLoop();
                window.addEventListener("beforeunload", unlockSerial);

            } catch (err) {
                console.error(err);
                addSystemMessage("Erro Serial: " + err.message, 'error');
            }
        }

        async function readSerialLoop() {
            try {
                while (serialPort.readable && isSerialConnected) {
                    const { value, done } = await serialReader.read();
                    
                    if (done) {
                        console.log("Stream leitura finalizado.");
                        break; 
                    }
                    
                    if (value) {
                        // 1. MOSTRA IMEDIATO NA TELA LOCAL (Latência Zero para mim)
                        appendToTerminal(value);

                        // 2. ACUMULA NO BUFFER PARA ENVIO CONTROLADO (Remoto)
                        serialOutBuffer += value;
                        flushSerialBuffer();
                    }
                }
            } catch (error) {
                console.error("Erro loop leitura:", error);
                addSystemMessage("Erro na leitura da serial. Verifique o dispositivo.", 'error');
            }
        }

        function unlockSerial() {
            // Envia o que restar no buffer antes de desconectar
            flushSerialBuffer();

            if (!isSerialConnected) return;
            if (serialWriter) serialWriter.close();
            if (serialReader) serialReader.cancel();
            if (serialPort) serialPort.close();
            isSerialConnected = false;
            serialPort = null;

            elBtnConnectSerial.textContent = "Conectar Serial";
            elBtnConnectSerial.disabled = false;

            if (isConnectedToMQTT) {
                const topicBase = `multry/${currentRoom}`;
                publishMessage(`${topicBase}/serial/lock`, JSON.stringify({ action: 'unlock' }));
                publishMessage(`${topicBase}/presence`, JSON.stringify({ type: 'update_serial', id: myId, hasSerial: false }));
            }
        }

        function updateSerialLock(data) {
            if (data.action === 'lock') {
                serialLockedBy = data.id;
                if (data.id !== myId) {
                    elBtnConnectSerial.disabled = true;
                    elBtnConnectSerial.textContent = `Serial em uso por ${data.name}`;
                }
            } else if (data.action === 'unlock') {
                if (serialLockedBy === data.id) {
                    serialLockedBy = null;
                    if (!isSerialConnected) {
                        elBtnConnectSerial.disabled = false;
                        elBtnConnectSerial.textContent = "Conectar Serial";
                    }
                }
            }
            if (users[data.id]) {
                users[data.id].hasSerial = (data.action === 'lock');
                renderUsers();
            }
        }

        function appendToTerminal(text) {
            const span = document.createElement('span');
            span.textContent = text;
            elTerminalOutput.appendChild(span);
            requestAnimationFrame(() => {
                elTerminalOutput.scrollTop = elTerminalOutput.scrollHeight;
            });
        }

        function focusTerminalInput() {
            elTerminalInputHidden.focus();
        }

        // --- FILTRO DE INPUT RIGOROSO ---
        elTerminalInputHidden.addEventListener('input', (e) => {
            if (e.inputType !== "insertText") {
                e.target.value = '';
                return;
            }

            const text = e.data || e.target.value;
            
            if (text && text.length === 1) {
                const code = text.charCodeAt(0);
                if (code >= 32) {
                    if (isConnectedToMQTT) {
                        const topicBase = `multry/${currentRoom}`;
                        publishMessage(`${topicBase}/serial/input`, text);
                    }
                }
            }
            e.target.value = '';
        });

        elTerminalInputHidden.addEventListener('keydown', (e) => {
            if (e.key === 'Backspace') {
                e.preventDefault(); 
                if (isConnectedToMQTT) {
                    const topicBase = `multry/${currentRoom}`;
                    publishMessage(`${topicBase}/serial/input`, '\x7F'); 
                }
                elTerminalInputHidden.value = ''; 
            } else if (e.key === 'Enter') {
                if (isConnectedToMQTT) {
                    const topicBase = `multry/${currentRoom}`;
                    publishMessage(`${topicBase}/serial/input`, '\r');
                }
                elTerminalInputHidden.value = '';
            }
        });

        function sendSpecialChar(char) {
            if (isConnectedToMQTT) {
                const topicBase = `multry/${currentRoom}`;
                publishMessage(`${topicBase}/serial/input`, char);
            }
            focusTerminalInput();
        }

        function sendModifiedKey(modifier) {
            let inputId = (modifier === 'c') ? 'ctrl-char' : 'alt-char';
            let inputEl = document.getElementById(inputId);
            if (inputEl) {
                let char = inputEl.value.toLowerCase();
                if (char.length === 1) {
                    let code = char.charCodeAt(0);
                    let payload = '';
                    if (modifier === 'c' && code >= 97 && code <= 122) {
                        payload = String.fromCharCode(code - 96);
                    } else if (modifier === 'a') {
                        payload = '\x1b' + char;
                    }
                    if (payload && isConnectedToMQTT) {
                        const topicBase = `multry/${currentRoom}`;
                        publishMessage(`${topicBase}/serial/input`, payload);
                        inputEl.value = '';
                        focusTerminalInput();
                    }
                }
            }
        }

        function logSerialData(data, direction) {
            const div = document.createElement('div');
            const timestamp = new Date().toLocaleTimeString();
            let cleanData = data.replace(/[\x00-\x1F\x7F]/g, (m) => {
                const special = {'\t':'TAB','\n':'LF','\r':'CR', '\x7F':'DEL'};
                return special[m] ? `{${special[m]}}` : `{\\x${m.charCodeAt(0).toString(16)}}`;
            });
            div.className = (direction === 'tx') ? 'log-tx' : 'log-rx';
            div.textContent = `[${timestamp}] ${direction === 'tx' ? '>>' : '<<'} ${cleanData}`;
            elSerialLog.appendChild(div);
            
            requestAnimationFrame(() => {
                elSerialLog.scrollTop = elSerialLog.scrollHeight;
            });
        }

        function escapeHtml(text) {
            return text.replace(/[&<>"']/g, function(m) { 
                return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"\'":'&#039;'}[m]; 
            });
        }

        window.addEventListener('beforeunload', () => {
            if (isConnectedToMQTT) {
                const topicBase = `multry/${currentRoom}`;
                publishMessage(`${topicBase}/presence`, JSON.stringify({ type: 'leave', id: myId }));
                unlockSerial();
            }
        });
    </script>
</body>
</html>
